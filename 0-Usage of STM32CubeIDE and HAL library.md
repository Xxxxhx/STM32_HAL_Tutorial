# Usage of STM32CubeIDE and HAL library

Considering that the current IDE used in the lab, Keil MDK, only supports Windows, and the given third library(key.h, LED.h, EXIT.h, etc) provided by ALIENTEK cannot help us learn how to use STM32 well, we decide to change the IDE from Keil MDK to STM32CubeIDE, which is free, open source and available in Windows, Mac OS and Linux. What's more, switch to STM32CubeIDE can help us understand STM32 well.

We also need to change the library from standard library to HAL library. Because standard library is old and has poor portability while STM32CubeIDE only supports HAL library. Thus, third library provided by ALIENTEK, like the key.h, LED.h, EXIT.h will be not recommended to be used in the following lab, and STM32CubeIDE will help us configure these peripherals.

STM32CubeIDE is the combination of STM32CubeMX and TrueStudio. The former is a graphical tool that provides a easy way to configure the STM32 MCU and generate corresponding codes, while the latter is an IDE like Keil IDE, but it is free, open-source(based on Eclipse c++) and multi-OS supported.

## Download and Install

Go to the website [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html) to download and install STM32CubeIDE. If you don't like the Eclipse style IDE, you also can use [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html) directly. You can use STM32CubeMX to generate code for Keil MDK, and also can generate code for CLion and MakeFile, in which case you need to handle the [GNU Arm Embedded toolchain](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm), GDB, MakeFile and ST-Link/JLink driver by yourself.

## Usage

![1570248288927](Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570248288927.png)

- New a STM32 project and select the corresponding MCU, click next to input the project name and than click finish end **Target Selection**.

When we firstly new a F1-series MCU project, STM32CubeIDE will download and extract the HAL library automatically. We also can load the HAL library directly by our own.

### RCC and Clock Configuration

First thing we need to do is to enable and configure the clock, which has introduced in the pervious lab. There are four kinds of clock sources in STM32: HSE clock, HSI clock, LSE clock and LSI clock(HS for high speed, LS for low speed, E for external and I for internal). Only the former two can used to driven the SYSCLK(System Clock), but most of the case we use HSE to drive the SYSCLK because the HSI clock signal is generated from RC oscillator, which is less accurate than an external crystal oscillator or ceramic resonator.

![1570280722629](Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570280722629.png)

- Click the **RCC** in the **System Core** categories and set the mode of HSE as **Crystal/Ceramic Resonator**

Then we switch to Clock Configuration tab

![1570281695220](Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570281695220.png)

This is the clock tree for STM32 F1 series MCU. From the clock tree we find PLLCLK also can drive the SYSCLK. PLLCLK signal is generated by PLL frequency multiplication, which uses HSE and HSI signal as input. It is all known that different peripherals need different frequencies of clock and we can use PLL multiplication and prescaler to configure the frequencies of peripherals’ clock flexibility.

### Pinout Configuration

Back to the **Pinout & Configuration** tab. For each pin, it has at most 16 alternate functions and can be configured as one of them.

If we want to toggle the LED, we need to set pin PD2 and PA8 as GPIO output and click the gear button to generate code.

![1570288776518](Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570288776518.png)

- set pin PD2 and PA8 as GPIO output

![1570288508879](Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570288508879.png)

- Before we generate the code, tick the option **Generate peripheral initialization as a pair of ‘.c/.h’ files per peripheral**, which will make the codes more modular.



## Programming 

STM32CubeIDE has generated codes for us according our configuration. The last thing we need to do is flash the LED.

```c
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    HAL_Delay(1000);
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
    HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_2);
  }
  /* USER CODE END 3 */
}
```

- Remember to put our codes into the **USER CODE** comment block, otherwise, STM32CubeIDE will overwrite them.

<img src="Usage%20of%20STM32CubeIDE%20and%20HAL%20library.assets/1570290290836.png" alt="1570290290836" style="zoom:150%;" />

- click the **debug** button to compile the project and program the binary file into the MCU, and click the **Resume** button to run the code on the MCU. You will see the LEDs flashing.
